//
//  main.c
//  CF.Hashmap00
//
//  Created by Alan Sampson on 10/20/20.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <search.h>

#define VALUES_L 60

uint32_t * collect(size_t const values_l, size_t * vals_max_p, uint32_t values[VALUES_L]);
void driven(size_t vals_max, uint32_t values[VALUES_L]);

typedef struct mapentry mapentry;
struct mapentry {
  char    key[10];
  int32_t value;
};

void fail(char * message) {
  perror(message);
  exit(EXIT_FAILURE);
}

size_t const map_slots = VALUES_L;

/*
 *  MARK: main()
 */
int main(int argc, const char * argv[]) {
  printf("DimgrayVacantMalware\n");

  size_t const values_l = VALUES_L;
  uint32_t values[VALUES_L] = { 0, };
  size_t vals_max;

  collect(values_l, &vals_max, values);

  for (size_t ix = 0; ix < vals_max; ++ix) {
    printf("%1$#010x [%1$10u,%1$012o]\n", values[ix]);
  }
  putchar('\n');

  driven(vals_max, values);

  return EXIT_SUCCESS;
}

/*
 *  MARK: collect()
 */
uint32_t * collect(size_t const values_l, size_t * vals_max_p,  uint32_t values[VALUES_L]) {
  printf("Function: %s\n", __func__);

  printf("Values to input (1 - %zu): ", values_l);
  fflush(stdout);
  scanf("%zu", vals_max_p);
  if (*vals_max_p < 1 || *vals_max_p > values_l) {
    fprintf(stderr, "\nvalue out of range: %zu\n", *vals_max_p);
    exit(EXIT_FAILURE);
  }
  putchar('\n');

  printf("provide %zu values: ", *vals_max_p);
  fflush(stdout);
  for (size_t ix = 0; ix < *vals_max_p; ++ix) {
    scanf("%i", &values[ix]);
  }
  putchar('\n');

  return values;
}

/*
 *  MARK: driven()
 */
void driven(size_t vals_max, uint32_t values[VALUES_L]) {
  printf("Function: %s\n", __func__);

  if (hcreate(map_slots) == 0) {
    fail("hcreate");
  }

  mapentry kvpairs[map_slots] = { 0, };

  for (size_t ix = 0; ix < vals_max; ++ix) {
    char key[10];
    sprintf(key, "%08X", values[ix]);
    strcpy(kvpairs[ix].key, key);
    kvpairs[ix].value = (uint32_t) ix + 1;
  }

  { //  store
    printf("Store data in map\n");
    for (size_t ix = 0; ix < vals_max; ++ix) {
      char    * key   = malloc(sizeof kvpairs[ix].key);
      int32_t * value = malloc(sizeof kvpairs[ix].value);

      strcpy(key, kvpairs[ix].key);
      value = &kvpairs[ix].value;
      ENTRY   entKV = { .key = key, };
      ENTRY * entKV_p = hsearch(entKV, ENTER);
      if (entKV_p == NULL) {
        fail("hsearch");
      }

      entKV_p->data = (void *) value;
      printf("%p %p\n", entKV_p->key, entKV_p->data);
      printf("%s %d\n", entKV_p->key, *((int32_t *) entKV_p->data));
    }
    putchar('\n');
  }

  { //  fetch
    printf("Fetch data from map\n");
    for (size_t ix = 0; ix < vals_max; ++ix) {
      char  * key = malloc(sizeof(kvpairs[ix].key));
      if (key == NULL) {
        exit(EXIT_FAILURE);
      }

      strcpy(key, kvpairs[ix].key);
      uint32_t svalue;
      ENTRY   entKV = { .key = key, };
      ENTRY * entKV_p = hsearch(entKV, FIND);
      if (entKV_p != NULL) {
        char * skey;
        skey   = entKV_p->key;
        svalue = *((int32_t *) entKV_p->data);
        printf("Key: %10s - Value: %3d\n", skey, svalue);
      }
      else {
        printf("Key: %10s not found.\n", kvpairs[ix].key);
      }
      free(key);
    }
    putchar('\n');
  }

  hdestroy();

  return;
}
